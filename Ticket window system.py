# -*- coding: utf-8 -*-
"""Tugas Python (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10YDx66h1lZbn0dL4FK6V7i9OhGWUSc_q

**Appendix :**<br>
**Ticket window system**: The theater has a conductor who is responsible for selling tickets at the window and receiving telephone consultation service at the same time. The window service takes priority over the telephone service. Inquiries can be stored by the telephone storage system in sequence (up to five lines) and answered by the conductor. The purpose of the modeling is to study the busy and idle situation of conductors, the average time for customers to buy tickets and the average time for waiting in line. The arrival time and service time can be adjusted as model parameters. Inventory system model.


---


# Simulation results analysis
 - Objective: To master the basic method of final state simulation results analysis and understand the sequential program.

### code
"""

import random
import statistics
import math

# Function to run a single simulation
def run_single_simulation():
  busy_times = []  # Store busy times for each run
  idle_times = []  # Store idle times for each run
  purchase_times = []  # Store purchase times for each run
  queue_times = []  # Store queue times for each run

  # Simulate ticket window system for a certain number of customers
  num_customers =+6  # Example: simulate for 10 customers
  for _ in range(num_customers):
    # Simulate ticket purchase process
    purchase_time = random.uniform(3, 8)  # Example data for purchase time
    purchase_times.append(purchase_time)

    # Simulate queue time (waiting time)
    queue_time = random.uniform(1, 5)  # Example data for queue time
    queue_times.append(queue_time)

    # Determine busy or idle time for conductor
    if queue_time > 3:
      busy_time = random.uniform(5, 10)  # Example data for busy time
      idle_time = 0
    else:
      busy_time = 0
      idle_time = random.uniform(2, 7)  # Example data for idle time

    busy_times.append(busy_time)
    idle_times.append(idle_time)

  return busy_times, idle_times, purchase_times, queue_times

# Function to calculate confidence interval
def calculate_confidence_interval(data, confidence_level):
  mean = statistics.mean(data)
  stdev = statistics.stdev(data)
  z_value = statistics.NormalDist().inv_cdf((1 + confidence_level) / 2)
  margin_of_error = z_value * stdev / (len(data) ** 0.5)
  lower_bound = mean - margin_of_error
  upper_bound = mean + margin_of_error
  return lower_bound, upper_bound

# Function to calculate minimum number of runs needed for desired confidence interval
def calculate_min_runs(confidence_level, desired_accuracy):
  # Z-value for a given confidence level
  z_value = 1.645  # For 90% confidence level

  # Calculate minimum number of runs needed
  min_runs = ((z_value / desired_accuracy) ** 2)

  return math.ceil(min_runs)

# Function to run simulation and calculate confidence intervals
def run_and_calculate_intervals(num_simulations, min_samples):
  all_queue_times = []

  for _ in range(num_simulations):
    # Run simulation and collect queue times
    _, _, _, queue_times = run_single_simulation()  # Extract only queue times
    all_queue_times.extend(queue_times)

  # Calculate confidence interval for queue times
  confidence_level = 0.90  # You can adjust this as needed
  queue_interval = calculate_confidence_interval(all_queue_times, confidence_level)

  return queue_interval

"""### 1. Run the simulation program in Experiment 2 . (5) times independently."""

# Step 1: Run the simulation program in Experiment 2 (5) times independently
num_simulations = 5

all_busy_times = []
all_idle_times = []
all_purchase_times = []
all_queue_times = []

for _ in range(num_simulations):
    # Run the simulation and collect data
    busy_times, idle_times, purchase_times, queue_times = run_single_simulation()

    # Store results from each run
    all_busy_times.append(busy_times)
    all_idle_times.append(idle_times)
    all_purchase_times.append(purchase_times)
    all_queue_times.append(queue_times)

# Display results from each run
for i in range(num_simulations):
    print(f"Run {i+1} Results:")
    print(f"Busy Times: {all_busy_times[i]}")
    print(f"Idle Times: {all_idle_times[i]}")
    print(f"Purchase Times: {all_purchase_times[i]}")
    print(f"Queue Times: {all_queue_times[i]}")
    print()

"""### 2.Calculate the minimum number of runs required to obtain the confidence interval of 90% confidence of the average queuing time index of customers with an accuracy of 0.1 minutes."""

# Step 2: Calculate the minimum number of runs required to obtain the confidence interval
min_samples = calculate_min_runs(0.90, 0.1)
print(f"Minimum number of runs needed: {min_samples}")

"""### 3.Complete the required number of independent runs of the simulation test and calculate the confidence interval."""

confidence_level = 0.9  # You can adjust this value

queue_interval = run_and_calculate_intervals(num_simulations, min_samples)

print(f"Confidence Interval for Queue Time ({confidence_level * 100}%):"
      f" [{queue_interval[0]:.2f} - {queue_interval[1]:.2f}]")

"""### 4. Using the sequential program to obtain the 90% confidence interval and 1% accuracy of each index of the busy and idle situation of the conductor, the average time of purchasing tickets and the average queuing time of the customers.

"""

# Step 4: Using the sequential program to obtain the 90% confidence interval and 1% accuracy of each index
busy_intervals = [calculate_confidence_interval(data, 0.90) for data in all_busy_times]
idle_intervals = [calculate_confidence_interval(data, 0.90) for data in all_idle_times]
purchase_intervals = [calculate_confidence_interval(data, 0.90) for data in all_purchase_times]
queue_intervals = [calculate_confidence_interval(data, 0.90) for data in all_queue_times]

# Display results
print("90% Confidence Intervals:")
print(f"Busy Time Intervals: {busy_intervals}")
print(f"Idle Time Intervals: {idle_intervals}")
print(f"Purchase Time Intervals: {purchase_intervals}")
print(f"Queue Time Intervals: {queue_intervals}")

